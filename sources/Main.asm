;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;																																												;
;	Author:				Yulquen74		 																																		;
;	Project:			A1200 Reset Device MK2																																	;
;	Source name:		Main.asm																																				;
;	Source version:		V1.0																																					;
;	Date:				04.10.2024																																				;
;	Description:		PIC is part of the Amiga Demo Launcher (ADL) reset device, which plugs into the A1200 serial port, as the hardware extension of ADL.					;
;						The purpose of the device is to do a hardware reset of the Amiga after a specified amount of time.														;
;						The user case for this is when launching demo's that does not exit by themselves.																		;
;						With the MK2 version of this device, it is also possible to apply a specified number of left mouse clicks, separated by a specified amount of time.		;
;						The user case for this is when launching multi-part/mega-demos that requires a left click to continue to the next part.									;
;						In both cases, the ADL software sends a command string to the Amiga serial port, which is then carried out by the reset device.							;
;						On the PCB it is possible to strap the reset device for reset stretching. This means that if the device detects a reset pulse issued externally			;
;						(not by itself) it will issue its own reset pulse to guarantee a 500ms pulse. The use case here is that sometimes overclocked Amiga accelerators, when 	;
;						issuing a software reset, the pulse is so short that the A1200 is not properly reset, and might hang in non-defined state.								;				
;																																												;
;						Command format is in ASCII using the template <#nnnnr,ccLF>																								;
;						<#>:			Every command string starts with a hash character, and reception of a hash also always demarks the start of a valid command string.		;		
;						<nnnn>:			Delay (counter) parameter, ASCII digit range 0000 - 9999.																				;				
;										<0000> = Cancels any previously received command and its activities.																	;
;										<0001> - <9999> = 1 - 9999 seconds reset or left click delay delay for single/mulipart demos.											;
;						<r>:			<0>: Use for single part demos.																											;
;										<1-F>: Use for multi-part demo with 2-16 parts, where a left click is needed to continue to the next part (final part ends with a reset);
;						<,>:			Field separator character.																												;
;						<cc>:			8-bit checksum represented as ASCII hex using 2 digits 0-9 and a-f/A-F. Checksum is generated by doing binary add of all characters 	;
;										from the start (#) to and including the field separator character (,) while keeping the low byte of the result.							;
;						<LF>:			Line Feed character (hex 0x0a), denotes the end of the string.																			;	
;						Test commands:	#00100,40<LF>	(will issue a 500ms reset 10 seconds after command is received)															;
;										#00000,3F<LF>	(will stop delayed reset timer, if running).																			;
;										#00601,46<LF>	(will issue a 500ms left click after 60 seconds, and after another 60 seconds a reset will be issued).					;					
;						Buzzer:			100ms beep (4KHz) indicates reception of a valid delayed reset or left click command.													;			
;										100ms beep (4KHz) x 2 indicates reception of a valid cancel command.																	;
;										500ms beep (4KHz) indicates reset in progress.																							;
;										250ms beep (4KHz) indicates a left click in progress.																					;				
;	Status:				Dev.																																					;
;																																												;
;	Device:				PIC12F1572																																				;
;																																												;
;	Notes:				RA0 (PIN 7):	->	A1200 Left Mouse Click Output ("Open Drain": Asserted = Output Enabled with Active Low / DeAsserted = Input)						;																					
;						RA1 (PIN 6):	<- 	RX input (5V level, 2400bps, 8N1)																									;																			
;						RA2 (PIN 5): 	->	Reset output (Open Drain: Asserted = Output Enabled with Active Low / DeAsserted = Input)											;																																						
;						RA3 (PIN 4):	<- 	Reset detect input																													;													
;						RA4 (PIN 3):	->	Buzzer output (use a passive buzzer with resonance frequency around 4KHz)															;
;						RA5 (PIN 2):	<-	4MHz clock input																													;
;																																												;
;	Release history:	V1.0:	Initial release																																	;
;																																												;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 

				processor						12f1572		

				#include						"p12f1572.inc"

				__CONFIG						_CONFIG1, _FOSC_ECM & _WDTE_OFF & _PWRTE_OFF & _MCLRE_OFF & _CP_OFF & _BOREN_OFF & _CLKOUTEN_OFF
				__CONFIG						_CONFIG2, _WRT_OFF & _PLLEN_OFF & _STVREN_OFF & _BORV_LO & _LPBOREN_OFF & _LVP_OFF

				radix							dec
		
				#include						<p12f1572.inc>

				;General Purpose RAM (0x20 - 0x6f), Bank 0 must be selected
				cblock							0x20				
				bnkRX_BUF_0						;-
				bnkRX_BUF_1						;-
				bnkRX_BUF_2						;-
				bnkRX_BUF_3						;-
				bnkRX_BUF_4						;-
				bnkRX_BUF_5						;-
				bnkRX_BUF_6						;-
				bnkRX_BUF_7						;-
				bnkRX_BUF_8						;-
				bnkRX_BUF_9						;-Receive Buffer for Terminal Rx
				endc
					
				;Common / Access RAM (0x70 - 0x7f), available in all Banks
				cblock							0x70	
				acsSCRATCH						;General purpose scratch register
				acsSYSTEM0						;-
				acsSYSTEM1						;-
				acsSYSTEM2						;-System flags
				acsCMD_DLY_HI					;-
				acsCMD_DLY_LO					;-Storage register pair for Command Delay received from serial command string
				acsCMD_TMR_HI					;-				
				acsCMD_TMR_LO					;-Timer Register pair used as down-counter for reset and left click delay 
				acsBUZ_TMR						;Buzzer Timer Register used as down-counter for Buzzer Period
				acsLCL_CNT						;Number of Left Click events to do, received from command serial command string
				acsBIN_HI						;-
				acsBIN_LO						;-Temp Registers for unit conversion				
				acs1S_PERIOD					;1 second period register
				acsRX_BUF_INDX					;Buffer Index for Terminal Rx
				endc	
				
				;System flag definitions	
				#define		bit1S				acsSYSTEM0,0	;bit set by TMR 2 based timebase when another second has passed.
				#define		bit4MS				acsSYSTEM0,1	;bit set by TMR 2 based timebase when another 4ms has passed
				#define		bitNEW_HLT_CMD		acsSYSTEM0,2	;bit is set when a new Halt Command string has been received
				#define		bitNEW_RST_CMD		acsSYSTEM0,3	;bit is set when a new Reset Command string has been received
				#define		bitNEW_LCL_CMD		acsSYSTEM0,4	;bit is set when a new Left Click Command string has been received
				#define		bitTERM_RX_RP0		acsSYSTEM0,5	;Return path for Terminal Rx routine
				#define		bitHLT_CMD_RP0		acsSYSTEM0,6	;-
				#define		bitHLT_CMD_RP1		acsSYSTEM0,7	;-
				#define		bitHLT_CMD_RP2		acsSYSTEM1,0	;-Return path for Halt Command routine
				#define		bitRST_CMD_RP0		acsSYSTEM1,1	;-
				#define		bitRST_CMD_RP1		acsSYSTEM1,2	;-
				#define		bitRST_CMD_RP2		acsSYSTEM1,3	;-Return path for Reset Command routine
				#define		bitLCL_CMD_RP0		acsSYSTEM1,4	;-
				#define		bitLCL_CMD_RP1		acsSYSTEM1,5	;-
				#define		bitLCL_CMD_RP2		acsSYSTEM1,6	;-
				#define		bitLCL_CMD_RP3		acsSYSTEM1,7	;-
				#define		bitLCL_CMD_RP4		acsSYSTEM2,0	;-Return path for Left Click Command routine
				#define		bitRST_STR_RP0		acsSYSTEM2,1	;-
				#define		bitRST_STR_RP1		acsSYSTEM2,2	;-Return path for Reset Stretch routine
				#define		bitRST_STAT			acsSYSTEM2,3	;Reset output status flag
				#define		bitLCL_STAT			acsSYSTEM2,4	;Left click output status flag
				#define		bitBUZ_STAT			acsSYSTEM2,5	;Buzzer status flag		
				#define		bitERROR0			acsSYSTEM2,6	;
				#define		bitERROR1			acsSYSTEM2,7	;				
								
				;Constants		
				#define		conANSELA_INIT		b'00000000'		;ANSEL: No analogue port pins
				#define		conLATA_INIT		b'00111010'		;LATA Idle State initialization: Buzzer Output = Disabled (High), Reset and LCK outputs set to Active value (Low)
				#define		conTRIS_INIT		b'00111111'		;TRIS Idle State initialization (N_RST and N_LCK outputs DeAsserted)
				#define		conBUZ_ON			b'11101111'		;Buzzer Output Enable AND mask
				#define		conBUZ_OFF			b'00010000'		;Buzzer Output Disable OR mask				
				#define		conN_RST_ASSERT		b'00111011'		;Active Low Reset Assert AND mask
				#define		conN_RST_DEASSERT	b'00000100'		;Active Low Reset DeAssert OR mask
				#define		conN_LCL_ASSERT		b'00111110'		;Active Low Left Click Assert AND mask
				#define		conN_LCL_DEASSERT	b'00000001'		;Active Low Left Click DeAssert OR mask
				
				#define		conLATA_BUZ_TGL		b'00010000'		;PORTA Buzzer Toggle XOR mask
				#define		conLF				0x0a			;Line Feed character definition	
				
				#define		conOPTION_REG_INIT	b'10001000'		;No Weak Pullup, no TIMER 0 Prescaler, TIMER 0 uses FOSC/4 as Clock 
				#define		conPIN_CTRL			b'00000000'		;EUSART RX pin set to RA1 (TX on RA0, but is not used)
				#define		conINTCON_INIT		b'10100000'		;INTERRUPT init: Enable TIMER 0 interrupts, turn on Interrupt main switch
				#define		conIOCAP_INIT		b'00000000'		;Interrupt On Change Positive Edge setup
				#define		conIOCAN_INIT		b'00001000'		;Interrupt On Change Negative Edge setup
				#define		conT1CON_INIT		b'00000101'		;TIMER1: Clock Source = FOSC/4 / Prescaler = 1 / Timer 1 On	
				#define		conT1GCON_INIT		b'00000000'		;TIMER1 Gate Control init:TIMER 1 Gate Enable bit disabled
				#define		conT2CON_INIT		b'00000110'		;TIMER2 init: Prescaler = 16, Postscaler = 1, Timer 2 On
				#define		conPR2_INIT			d'249'			;TIMER2 Period Register init = 249
																;TIMER2 Freq. = (Fosc/4) / Prescaler / Postscaler / (Period Reg. + 1) = 250Hz
				#define		conTXSTA_INIT		b'00000000'		;EUSART TXSTA: TX disabled, EUSART Async mode, Low speed (BRGH=0) 
				#define		conRCSTA_INIT		b'10010000'		;EUSART RCSTA: Serial port is enabled, 8 bit Reception, Continous Receive, no Address Detect
				#define		conBAUDCON_INIT		b'00000000'		;EUSART BAUDCON: 8 bit Baud Rate Generator, Wake Up disabled, Auto Baud Mode disabled
				#define		conSPBRGH_INIT		b'00000000'		;-
				#define		conSPBRG_INIT		d'25'			;-SPBRG
				#define		conTMR0_ADJ			d'134'			;TIMER0: Adjustment value to approximate 8KHz interrupt rate
				#define		con1S_PERIOD_INIT	d'250'			;
				#define		conTMR2_MS			((1 * 1000) / ((1000000 / 250) / 16))					
		
				#define		con100MS			100 / conTMR2_MS ;
				#define		con250MS			250 / conTMR2_MS ;					
				#define		con500MS			500 / conTMR2_MS ;
				#define		con1000MS			1000 /conTMR2_MS ;
					
					
ORG	0x00		;Reset Vector
Start			;Startup Code	
				clrf		STATUS				;
				clrf		BSR					;
				clrf		INTCON				;
				goto		Init				;

					
ORG	0x04		;Interrupt Vector			
ISR				;Interrupt Service Routine
				bcf			INTCON,TMR0IF		;Clear TIMER 0 Interrupt flag
				banksel		TMR0				;-
				movlw		conTMR0_ADJ			;-
				addwf		TMR0,F				;-Adjust TIMER 0 ISR frequency for 8KHz
				banksel		LATA				;-
				movlw		conLATA_BUZ_TGL		;-	
				xorwf		LATA,F				;-Toggle Buzzer Output			
				retfie							;Exit ISR
				
					
Init			;Initialization of Hardware and Registers		
				banksel		OPTION_REG			;-
				movlw		conOPTION_REG_INIT	;-
				movwf		OPTION_REG			;-
				banksel		APFCON				;-
				movlw		conPIN_CTRL			;-
				movwf		APFCON				;-
				banksel		ANSELA				;-
				movlw		conANSELA_INIT		;-
				movwf		ANSELA				;-
				banksel		LATA				;-
				movlw		conLATA_INIT		;-
				movwf		LATA				;-
				banksel		TRISA				;-
				movlw		conTRIS_INIT		;-
				movwf		TRISA				;-
				banksel		IOCAP				;-
				movlw		conIOCAP_INIT		;-	
				movwf		IOCAP				;-
				banksel		IOCAN				;-
				movlw		conIOCAN_INIT		;-	
				movwf		IOCAN				;-
				banksel		T1CON				;-
				movlw		conT1CON_INIT		;-
				movwf		T1CON				;-
				banksel		T1GCON				;-
				movlw		conT1GCON_INIT		;-
				movwf		T1GCON				;-
				banksel		T2CON				;-
				movlw		conT2CON_INIT		;-
				movwf		T2CON				;-
				banksel		PR2					;-
				movlw		conPR2_INIT			;-
				movwf		PR2					;-
				banksel		SPBRGH				;-
				movlw		HIGH conSPBRGH_INIT	;-
				movwf		SPBRGH				;-
				banksel		SPBRGL				;-
				movlw		LOW conSPBRG_INIT	;-
				movwf		SPBRGL				;-
				banksel		BAUDCON				;-
				movlw		conBAUDCON_INIT		;-
				movwf		BAUDCON				;-
				banksel		TXSTA				;-
				movlw		conTXSTA_INIT		;-
				movwf		TXSTA				;-
				banksel		RCSTA				;-
				movlw		conRCSTA_INIT		;-	
				movwf		RCSTA				;-
				movlw		conINTCON_INIT		;-
				movwf		INTCON				;-Initialize hardware modules
				goto		Main				;			
					

;				#############################################################################				
;				#																			#
;				#			MAIN LOOP														#	
;				#																			#
;				#############################################################################
				
Main				
				call		TimeBase			;Update TimeBase			
				call		Terminal_Rx			;Update Serial Command String Reception
				call		HLT_Cmd				;Update Halt Command 
				call		RST_Cmd				;Update Reset Command
				call		LCL_Cmd				;Update Left Click Command
				call		RST_Stretch			;Update Reset Stretch
				goto		Main				;Repeat Loop
				
	
TimeBase		;Uses Hardware TIMER2 for 4ms and 1s TimeBase
				bcf			bit1S				;-
				bcf			bit4MS				;-Reset timebase flags
				banksel		PIR1				;-
				btfss		PIR1,TMR2IF			;-Have TIMER2 overflowed?
				return							;No, exit
				
				bsf			bit4MS				;Yes, set flag to indicate that another 4ms has passed
				bcf			PIR1,TMR2IF			;Clear TIMER2 interrupt flag
				decfsz		acs1S_PERIOD,F		;Decrement 1s period counter. Has it reached Zero? 
				return							;No, exit
				
				bsf			bit1S				;Yes, Set flag to indicate that another Second has passed
				movlw		con1S_PERIOD_INIT	;-
				movwf		acs1S_PERIOD		;-Prepare period register for next round
				return							;			

				
Terminal_Rx		;Receive Command Strings from the Serial Terminal / EUSART
				btfsc		bitTERM_RX_RP0		;-
				goto		Terminal_Rx_10		;-Execute ReturnPath

				;Wait for First Command String Byte
				banksel		PIR1				;
				btfss		PIR1,RCIF			;Have a new Byte been received by the EUSART?
				return							;No, Exit					
				
				;Check for Framing and Overrun Errors
				banksel		RCSTA				;
				btfsc		RCSTA,FERR			;Have a Framing Error occured?
				goto		Terminal_Rx_60		;Yes, go here to scrap buffer and finish
				
				btfsc		RCSTA,OERR			;Have an OverRun Error occured?
				goto		Terminal_Rx_60		;Yes, go here to scrap buffer and finish

				;Initialize Buffer Index Register
				clrf		acsRX_BUF_INDX		;Init Rx Buffer Index Register
				
				;Save First Byte
				call		Terminal_Rx_C1		;Save First Byte into Buffer and Increment Buffer Index Register
				
				bsf			bitTERM_RX_RP0		;Set Return Path to Terminal_Rx_10
				goto		Terminal_Rx_15		;
				
												Terminal_Rx_10	
				;LOOP: Wait for the Next Command String Byte								
				banksel		PIR1				;
				btfss		PIR1,RCIF			;Have a new Byte been received by the EUSART?
				return							;No, Exit

				;Check for Framing and Overrun Errors
				banksel		RCSTA				;
				btfsc		RCSTA,FERR			;Have a Framing Error occured?
				goto		Terminal_Rx_60		;Yes, go here to scrap buffer and finish
				
				btfsc		RCSTA,OERR			;Have an OverRun Error occured?
				goto		Terminal_Rx_60		;Yes, go here to scrap buffer and finish
				
				;Save Next Byte into Buffer
				call		Terminal_Rx_C1		;Save Next Byte into Buffer and Increment Buffer Index Register
				
				;Check if all Bytes has been Received
				movf		acsRX_BUF_INDX,W	;-
				sublw		d'10'				;-
				btfsc		STATUS,Z			;-Have all Command String Characters been received?
				goto		Terminal_Rx_20		;Yes, go here to continue
				
												Terminal_Rx_15
				;Check if a Premature Line Feed has been Received
				movf		INDF0,W				;-
				sublw		conLF				;-
				btfsc		STATUS,Z			;-Is current String Character a LineFeed?
				goto		Terminal_Rx_60		;Yes, go here to scrap buffer and exit
				return							;No, Exit

												Terminal_Rx_20
												
				;END OF LOOP: Check LineFeed Character		
				movf		INDF0,W				;-
				sublw		conLF				;-
				btfss		STATUS,Z			;-Is the Character String terminated with a LineFeed?
				goto		Terminal_Rx_60		;No, go here to scrap buffer and exit
				
				;Check Command String Start Character
				banksel		bnkRX_BUF_0			;
				movf		bnkRX_BUF_0,W		;-
				sublw		"#"					;-
				btfss		STATUS,Z			;-Is 1st Character a Hash?
				goto		Terminal_Rx_60		;No, go here to scrap buffer and exit
				
				;Check Command String Delay Counter Digits
				movlw		d'4'				;-
				movwf		acsSCRATCH			;-Init Digit Counter
				bcf			bitERROR0			;Init Error Flag
				movlw		HIGH bnkRX_BUF_1	;-
				movwf		FSR0H				;-
				movlw		LOW bnkRX_BUF_1		;-
				movwf		FSR0L				;-Init Digit Byte Pointer
				
												Terminal_Rx_30										
				movlw		"0"					;-
				subwf		INDF0,W				;-
				btfss		STATUS,C			;-Is current Character Digit below ASCII 0?
				bsf			bitERROR0			;Yes, set Error flag
				movf		INDF0,W				;-
				sublw		"9"					;-
				btfss		STATUS,C			;-Is current Character Digit above ASCII 9?
				bsf			bitERROR0			;Yes, set Error flag	
				addfsr		FSR0,d'1'			;Increment Digit Byte Pointer
				decfsz		acsSCRATCH,F		;Decrement Digit Counter. Has it reached Zero?
				goto		Terminal_Rx_30		;No, repeat loop
				
				btfsc		bitERROR0			;Are Delay Counter Digits valid?
				goto		Terminal_Rx_60		;No, go here to scrap buffer and exit
							
				;Check Command String Multipart Count Digit
				movf		bnkRX_BUF_5,W		;-
				call		ASCIIHexToBin4		;-
				
				movwf		acsLCL_CNT			; (save for later)				
				btfsc		WREG,7				;-Is this character wihin range 0-9, a-f or A-F?
				goto		Terminal_Rx_60		;No, go here to scrap buffer and exit
								
				;Check Command String Field Separator Character
				movf		bnkRX_BUF_6,W		;-
				sublw		","					;-
				btfss		STATUS,Z			;-Is the Field Separator Character valid?
				goto		Terminal_Rx_60		;No, go here to scrap buffer and exit

				;Check Command String Checksum
				movf		bnkRX_BUF_0,W		;-
				addwf		bnkRX_BUF_1,W		;-
				addwf		bnkRX_BUF_2,W		;-
				addwf		bnkRX_BUF_3,W		;-
				addwf		bnkRX_BUF_4,W		;-
				addwf		bnkRX_BUF_5,W		;-
				addwf		bnkRX_BUF_6,W		;-
				movwf		bnkRX_BUF_9			;-Calculate Command String Checksum

				movf		bnkRX_BUF_7,W		;-
				call		ASCIIHexToBin4		;-
				
				btfsc		WREG,7				; Is Upper Checksum Digit Valid?	
				goto		Terminal_Rx_60		; No, go here to scrap buffer and exit
				
				swapf		WREG,W				;-
				movwf		acsSCRATCH			;-
				movf		bnkRX_BUF_8,W		;-
				call		ASCIIHexToBin4		;-
				
				btfsc		WREG,7				; Is Lower Checksum Digit Valid?	
				goto		Terminal_Rx_60		; No, go here to scrap buffer and exit
								
				iorwf		acsSCRATCH,W		;-
				subwf		bnkRX_BUF_9,W		;-
				btfss		STATUS,Z			;-Is Checksum received in Command String equal to the calculated one?
				goto		Terminal_Rx_60		;No, go here to scrap buffer and exit
				
				movlw		0x0f				;-
				andwf		bnkRX_BUF_1,F		;-
				andwf		bnkRX_BUF_2,F		;-
				andwf		bnkRX_BUF_3,F		;-
				andwf		bnkRX_BUF_4,F		;-Remove ASCII offset from delay digits

				;Conversion code below is a slightly changed version of BCD5ToBIN16 by Peter Hemsley / PicList
				;N = (((D1 + D3) * 2 + D2 * 16 + D2 + D3 * 256) * 2 - D3 * 16 + D2 * 16 + D1) * 2 + D0
				movf		bnkRX_BUF_3,W		;(D1 + D3) * 2
				addwf		bnkRX_BUF_1,W
				movwf		acsBIN_LO
				bcf			STATUS,C	
				rlf			acsBIN_LO,F

				swapf		bnkRX_BUF_2,W		; + D2 * 16 + D2
				addwf		bnkRX_BUF_2,W
				addwf		acsBIN_LO,F

				movf		bnkRX_BUF_1,W		; + D3 * 256
				movwf		acsBIN_HI

				bcf			STATUS,C
				rlf			acsBIN_LO,F			; * 2
				rlf			acsBIN_HI,F

				swapf		bnkRX_BUF_1,W		; - D3 * 16
				subwf		acsBIN_LO,F
				btfss		STATUS,C
				decf		acsBIN_HI,F

				swapf		bnkRX_BUF_2,W		; + D2 * 16 + D1
				addwf		bnkRX_BUF_3,W
				addwf		acsBIN_LO,F
				btfsc		STATUS,C
				incf		acsBIN_HI,F

				bcf			STATUS,C
				rlf			acsBIN_LO,F			; * 2
				rlf			acsBIN_HI,F

				movf		bnkRX_BUF_4,W		; + D0
				addwf		acsBIN_LO,F
				btfsc		STATUS,C
				incf		acsBIN_HI,F				
				;
							
				bcf			bitRST_CMD_RP0		;-
				bcf			bitRST_CMD_RP1		;-
				bcf			bitRST_CMD_RP2		;-
				bcf			bitLCL_CMD_RP0		;-
				bcf			bitLCL_CMD_RP1		;-
				bcf			bitLCL_CMD_RP2		;-
				bcf			bitLCL_CMD_RP3		;-
				bcf			bitLCL_CMD_RP4		;-
				bcf			bitHLT_CMD_RP0		;-
				bcf			bitHLT_CMD_RP1		;-
				bcf			bitHLT_CMD_RP2		;-
				call		BUZ_Off				;-
				call		N_RST_DeAssert		;-
				call		N_LCL_DeAssert		;-Stop all ongoing Command Routines and Activities	

				banksel		TMR2				;
				clrf		TMR2				;-
				banksel		PIR1				;
				bcf			PIR1,TMR2IF			;-
				clrf		acs1S_PERIOD		;-
				bcf			bit4MS				;-
				bcf			bit1S				;-Sync Timebase
				
				movf		acsBIN_HI,W			;-
				iorwf		acsBIN_LO,W			;-												
				btfss		STATUS,Z			;-Is digit 1-4 "0000" (Halt Command)?
				goto		Terminal_Rx_40		;No, go here to continue							
				
				bsf			bitNEW_HLT_CMD		;Signal Halt Command Routine
				goto		Terminal_Rx_70		;Go here to finish
				
												Terminal_Rx_40
				movf		acsBIN_HI,W			;-
				movwf		acsCMD_DLY_HI		;-
				movf		acsBIN_LO,W			;-
				movwf		acsCMD_DLY_LO		;-Load Delay Value
			
				banksel		bnkRX_BUF_5			;
				movf		bnkRX_BUF_5,W		;-
				sublw		"0"					;-
				btfss		STATUS,Z			;-Is this a Reset Command (LCK counter value is 0)?
				goto		Terminal_Rx_50		;No, its an LCK command, go here to continue

				bsf			bitNEW_RST_CMD		;Yes, Signal Reset Command Routine
				goto		Terminal_Rx_70		;Go here to finish			
				
												Terminal_Rx_50
				bsf			bitNEW_LCL_CMD		;Signal Left Click command Routine
				goto		Terminal_Rx_70		;Go here to finish		
				
												Terminal_Rx_60
				banksel		RCREG				;
				movf		RCREG,W				;-
				movf		RCREG,W				;-
				movf		RCREG,W				;-Empty EUSART Receive Buffer 
				bcf			RCSTA,CREN			;-
				nop								;-
				bsf			RCSTA,CREN			;-Clear any OverRun Error
			
												Terminal_Rx_70
				bcf			bitTERM_RX_RP0		;Reset Return Path			
				return
												Terminal_Rx_C1
				;Save Received byte into RX Buffer
				movlw		HIGH bnkRX_BUF_0	;-
				movwf		FSR0H				;-
				movlw		LOW bnkRX_BUF_0		;-
				addwf		acsRX_BUF_INDX,W	;-
				movwf		FSR0L				;-
				btfsc		STATUS,C			;-
				incf		FSR0H,F				;-
				banksel		RCREG				;
				movf		RCREG,W				;-
				movwf		INDF0				;-Save Received Byte into Buffer
				incf		acsRX_BUF_INDX,F	;Increment Buffer Index
				return							;	
					
				
HLT_Cmd			;Execute Halt Command			
				btfsc		bitHLT_CMD_RP2		;-
				goto		HLT_Cmd_30			;-
				btfsc		bitHLT_CMD_RP1		;-
				goto		HLT_Cmd_20			;-
				btfsc		bitHLT_CMD_RP0		;-
				goto		HLT_Cmd_10			;-Execute Return Path
				
				btfss		bitNEW_HLT_CMD		;Have a new Halt Command been received?
				return							;No, Exit
				
				bcf			bitNEW_HLT_CMD		;Clear Halt Command flag
				
				;Start of Halt Command Confirmation Beep 1
				call		BUZ_On				;Turn On Buzzer (Start of 100ms Command Confirmation Beep 1)	

				movlw		con100MS			;-
				movwf		acsBUZ_TMR			;-Start Buzzer Timer
				bsf			bitHLT_CMD_RP0		;Set Return Path to HLT_Cmd_10
				return								
												HLT_Cmd_10		
				btfss		bit4MS				;Has another 4ms passed?
				return							;No, Exit

				decfsz		acsBUZ_TMR,F		;Decrement Buzzer Timer. Has it reached Zero (100ms passed)?
				return							;No, Exit

				;End of Halt Command Confirmation Beep 1	
				call		BUZ_Off				;Turn Off Buzzer (End of 100ms Command Confirmation Beep 1)				
				
				movlw		con100MS			;-
				movwf		acsBUZ_TMR			;-Start Buzzer Timer
				bsf			bitHLT_CMD_RP1		;Set Return Path to HLT_Cmd_20
				return							;Exit
									
												HLT_Cmd_20
				btfss		bit4MS				;Has another 4ms passed?
				return							;No, Exit

				decfsz		acsBUZ_TMR,F		;Decrement Buzzer Timer. Has it reached Zero (100ms passed)?
				return							;No, Exit

				;Start of Halt Command Confirmation Beep 2
				call		BUZ_On				;Turn Off Buzzer (Start of 100ms Command Confirmation Beep 2)				

				movlw		con100MS			;-
				movwf		acsBUZ_TMR			;-Start Buzzer Timer
				bsf			bitHLT_CMD_RP2		;Set Return Path to HLT_Cmd_30
				return								
												HLT_Cmd_30
				btfss		bit4MS				;Has another 4ms passed?
				return							;No, Exit

				decfsz		acsBUZ_TMR,F		;Decrement Buzzer Timer. Has it reached Zero (100ms passed)?
				return							;No, Exit

				;End of Halt Command Confirmation Beep 2	
				call		BUZ_Off				;Turn Off Buzzer (End of 100ms Command Confirmation Beep 2)				
				
				bcf			bitHLT_CMD_RP2		;-
				bcf			bitHLT_CMD_RP1		;-
				bcf			bitHLT_CMD_RP0		;-Reset return path
				return							;Exit
				
				
RST_Cmd			;Execute Reset Command 
				btfsc		bitRST_CMD_RP2		;-
				goto		RST_Cmd_30			;-
				btfsc		bitRST_CMD_RP1		;-
				goto		RST_Cmd_20			;-
				btfsc		bitRST_CMD_RP0		;-
				goto		RST_Cmd_10			;-Execute ReturnPath

				btfss		bitNEW_RST_CMD		;Has a new Reset Command been Received?
				return							;No, Exit					
				
				bcf			bitNEW_RST_CMD		;Clear Command Flag
				
				;Start Buzzer Command Confirmation Beep 
				call		BUZ_On				;Turn On Buzzer (Start of 100ms command confirmation Beep)	

				movlw		con100MS			;-
				movwf		acsBUZ_TMR			;-Start Buzzer Timer
				bsf			bitRST_CMD_RP0		;Set Return Path to RST_Cmd_10
				return								
												RST_Cmd_10
				btfss		bit4MS				;Has another 4ms passed?
				return							;No, Exit

				decfsz		acsBUZ_TMR,F		;Decrement Buzzer Timer. Has it reached Zero (100ms passed)?
				return							;No, Exit

				;End of Buzzer Confirmation Beep 	
				call		BUZ_Off				;Turn Off Buzzer (End of 100ms command confirmation Beep)

				;Start of Reset Timer
				movf		acsCMD_DLY_HI,W		;-
				movwf		acsCMD_TMR_HI		;-
				movf		acsCMD_DLY_LO,W		;-
				movwf		acsCMD_TMR_LO		;-Load Reset Timer with value received from Serial Command String	
				bsf			bitRST_CMD_RP1		;Set ReturnPath to Update_Reset_Timer_20
				return							;

												RST_Cmd_20
				btfss		bit1S				;Has another second passed?
				return							;No, Exit

				movlw		D'1'				;-
				subwf		acsCMD_TMR_LO,F		;-
				movlw		0x00				;-
				subwfb		acsCMD_TMR_HI,F		;-
				movf		acsCMD_TMR_LO,W		;-
				iorwf		acsCMD_TMR_HI,W		;-
				btfss		STATUS,Z			;-Yes, decrement Reset Timer. Has it reached Zero?
				return							;No, Exit

				;Assert Reset Output and Turn On Buzzer
				call		N_RST_Assert		;Assert Reset Output
				call		BUZ_On				;Turn On Buzzer

				movlw		con500MS			;-
				movwf		acsBUZ_TMR			;-Load Buzzer Timer
				bsf			bitRST_CMD_RP2		;Set ReturnPath to RST_CMD_30
				return									
												RST_Cmd_30
				btfss		bit4MS				;Has another 4ms passed?
				return							;No, Exit

				decfsz		acsBUZ_TMR,F		;Decrement Buzzer Timer. Has it reached Zero?
				return							;No, Exit
				
				;DeAssert Reset Output and Turn Off Buzzer
				call		N_RST_DeAssert		;DeAssert Reset Output
				call		BUZ_Off				;Turn Off Buzzer
				
												RST_Cmd_50
				;Reset Return Path and Exit											
				bcf			bitRST_CMD_RP2		;-
				bcf			bitRST_CMD_RP1		;-
				bcf			bitRST_CMD_RP0		;-Reset Return Path
				return							;			
					
				
LCL_Cmd			;Execute Left Click Command 
				btfsc		bitLCL_CMD_RP3		;-
				goto		LCL_Cmd_60			;-
				btfsc		bitLCL_CMD_RP2		;-
				goto		LCL_Cmd_40			;-
				btfsc		bitLCL_CMD_RP1		;-
				goto		LCL_Cmd_30			;-
				btfsc		bitLCL_CMD_RP0		;-
				goto		LCL_Cmd_10			;-Execute ReturnPath

				btfss		bitNEW_LCL_CMD		;Have a new Left Click Command been Received?
				return							;No, Exit					

				bcf			bitNEW_LCL_CMD		;Clear Command Flag
				
				;Start Buzzer Command Confirmation Beep 
				call		BUZ_On				;Activate Buzzer (Start of command confirmation Beep)	
				
				movlw		con100MS			;-
				movwf		acsBUZ_TMR			;-Load Buzzer Timer
				bsf			bitLCL_CMD_RP0		;Set return path to LCL_CMD_10
				return							;Exit

												LCL_Cmd_10
				btfss		bit4MS				;Has another 4ms passed?
				return							;No, Exit

				decfsz		acsBUZ_TMR,F		;Decrement Buzzer Timer. Has it reached Zero (100ms passed)?
				return							;No, Exit

				;End of Buzzer Commanc Confirmation Beep 
				call		BUZ_Off				;Deactivate Buzzer (End of command confirmation Beep)

												LCL_Cmd_20
				;Start Of Left Click Timer									
				movf		acsCMD_DLY_HI,W		;-
				movwf		acsCMD_TMR_HI		;-
				movf		acsCMD_DLY_LO,W		;-
				movwf		acsCMD_TMR_LO		;-Load Left Click Timer with value received from Serial Terminal			
				bcf			bitLCL_CMD_RP2		;-
				bsf			bitLCL_CMD_RP1		;-Set ReturnPath to LCL_CMD_30
				return							;

												LCL_Cmd_30
				btfss		bit1S				;Has another second passed?
				return							;No, Exit

				movlw		d'1'				;-
				subwf		acsCMD_TMR_LO,F		;-
				movlw		0x00				;-
				subwfb		acsCMD_TMR_HI,F		;-Yes, Decrement LCK Timer register set
				movf		acsCMD_TMR_HI,W		;-
				iorwf		acsCMD_TMR_LO,W		;-
				btfss		STATUS,Z			;-Has it reached zero?
				return							;No, Exit
				
				;Left Click Timer has Finished	
				movf		acsLCL_CNT,W		;-
				btfsc		STATUS,Z			;-Has Left Click Counter reached Zero?
				goto		LCL_Cmd_50			;Yes, go here to continue with Reset

				;Assert Left Click Output, Turn on Buzzer
				call		N_LCL_Assert		;Assert Left Click Output
				call		BUZ_On				;Enable Buzzer
				
				movlw		con250MS			;-
				movwf		acsBUZ_TMR			;-Load Buzzer Timer
				bsf			bitLCL_CMD_RP2		;Set ReturnPath to LCL_CMD_40
				return									
												LCL_Cmd_40
				btfss		bit4MS				;Has another 4ms passed?
				return							;No, Exit

				decfsz		acsBUZ_TMR,F		;Decrement Buzzer Timer. Has it reached Zero?
				return							;No, Exit

				;End of Buzzer Timer: DeAssert Left Click Output, and Stop Buzzer
				call		N_LCL_DeAssert		;DeAssert Left Click Output
				call		BUZ_Off				;Disable Buzzer
				
				decf		acsLCL_CNT,F		;Decrement Left Click counter.
				
				;Repeat Left Click Loop
				goto		LCL_Cmd_20			;Go back to repeat left click Delay Phase

												LCL_Cmd_50
				;Assert Reset Output, Turn On Buzzer
				call		N_RST_Assert		;Assert Reset Output
				call		BUZ_On				;Enable Buzzer
				
				movlw		con500MS			;-
				movwf		acsBUZ_TMR			;-Load Buzzer Timer
				bsf			bitLCL_CMD_RP3		;Set ReturnPath to LCL_CMD_60
				return							;Exit					

												LCL_Cmd_60
				btfss		bit4MS				;Has another 4ms passed?
				return							;No, Exit

				decfsz		acsBUZ_TMR,F		;Decrement Buzzer Timer. Has it reached Zero?
				return							;No, Exit

				;End of Buzzer Timer: DeAssert Reset Output
				call		N_RST_DeAssert		;DeAssert Reset Output
				call		BUZ_Off				;Stop Buzzer
										
				bcf			bitLCL_CMD_RP3		;-					
				bcf			bitLCL_CMD_RP2		;-
				bcf			bitLCL_CMD_RP1		;-
				bcf			bitLCL_CMD_RP0		;-Reset Return Path
				return							;
					
				
RST_Stretch		;Detect External Reset, and extend Reset Pulse on Reset Output			
				btfsc		bitRST_STR_RP1		;-
				goto		RST_Stretch_20		;-
				btfsc		bitRST_STR_RP0		;-
				goto		RST_Stretch_10		;-Execute Return Path
				
				banksel		IOCAF				;
				btfss		IOCAF,IOCAF3		;Has a Negative Edge (Reset) been detected on port pin RA3?
				return							;No, Exit
				
				bcf			IOCAF,IOCAF3		;Yes, Clear Interrupt Flag
				btfsc		bitRST_STAT			;Is the Reset Line beeing Pulled Low by this chip?
				return							;Yes, Reset Stretch not necessary, Exit

				bsf			bitRST_STR_RP0		;Set Return Path to RST_Stretch_10
				
												RST_Stretch_10
				btfsc		bitBUZ_STAT			;Is Buzzer in use?
				return							;Yes, Exit

				btfsc		bitRST_STAT			;Is Reset Pin Asserted?
				return							;Yes, Exit
				
				call		N_RST_Assert		;Activate Reset Stretch
				call		BUZ_On				;Activate Buzzer
				
				movlw		con500MS			;-
				movwf		acsBUZ_TMR			;-Start Buzzer Timer

				bsf			bitRST_STR_RP1		;Set Return Path to RST_Stretch_20
				return							;Exit

												RST_Stretch_20
				btfss		bit4MS				;Has another 4ms passed?
				return							;No, Exit

				decfsz		acsBUZ_TMR,F		;Decrement Buzzer Timer. Has it reached Zero (100ms passed)?
				return							;No, Exit

				call		BUZ_Off				;Turn Off Buzzer (End of first 100ms command cancel Beep)				
				call		N_RST_DeAssert		;DeActivate Reset Stretch
								
				banksel		IOCAF				;
				bcf			IOCAF,IOCAF3		;clear Interrupt Flag
			
				bcf			bitRST_STR_RP0		;-				
				bcf			bitRST_STR_RP1		;-Reset Return Path										
				return		
			
				
;				#############################################################################				
;				#																			#
;				#			SUPPORT ROUTINES												#	
;				#																			#
;				#############################################################################
									
BUZ_On			;FUNCTION:						Turn On Buzzer
				;OUTPUT:	bitBUZ_STAT			Buzzer Status Flag					
				banksel		TRISA				;
				movlw		conBUZ_ON			;-
				andwf		TRISA,F				;-Turn On Buzzer
				bsf			bitBUZ_STAT			;Set Buzzer Status Flag
				return							;
				
BUZ_Off			;FUNCTION:							Turn Off Buzzer
				;OUTPUT:	bitBUZ_STAT			Buzzer Status Flag					
				banksel		TRISA				;-
				movlw		conBUZ_OFF			;-
				iorwf		TRISA,F				;-Turn Off Buzzer
				bcf			bitBUZ_STAT			;Clear Buzzer Status Flag
				return							;
			
				
N_RST_Assert	;FUNCTION:						Assert the Reset Output
				;OUTPUT:	bitRST_STAT			Reset Output Status Flag
				banksel		TRISA				;-
				movlw		conN_RST_ASSERT		;-
				andwf		TRISA,F				;-Assert Reset Output
				bsf			bitRST_STAT			;Set Reset Output Status Flag
				return
				

N_RST_DeAssert	;FUNCTION:						DeAsserts the Reset Output
				;OUTPUT:	bitRST_STAT			Reset Output Status Flag
				banksel		TRISA				;-
				movlw		conN_RST_DEASSERT	;-
				iorwf		TRISA,F				;-DeAssert Reset Output
				bcf			bitRST_STAT			;Clear Reset Output Status Flag
				return

				
N_LCL_Assert	;FUNCTION:						Assert the Left Click Output
				;OUTPUT:	bitLCL_STAT			Left Click Output Status Flag
				banksel		TRISA				;-
				movlw		conN_LCL_ASSERT		;-
				andwf		TRISA,F				;-Assert Left Click Output
				bsf			bitLCL_STAT			;Set Left Click Output Status Flag
				return
				

N_LCL_DeAssert	;FUNCTION:						DeAssert the Left Click Output
				;OUTPUT:	bitLCL_STAT			Left Click Output Status Flag
				banksel		TRISA				;-
				movlw		conN_LCL_DEASSERT	;-
				iorwf		TRISA,F				;-DeAssert Left Click Output
				bcf			bitLCL_STAT			;Clear Left Click Output Status Flag
				return
				
				
ASCIIHexToBin4	;FUNCTION:						Convert ASCII HEX character (0-9 / a-f / A-F) to 4-bit binary (0x0 - 0xf)
				;INPUT:		WREG				ASCII HEX character to convert
				;OUTPUT:	WREG				4-bit binary
				;NOTE:							If input character is Invalid, routine Exits with bit 7 of WREG Set	
				btfss		WREG,6				;Is ASCII Hex char 0x4x/0x5x/0x6x/0x7x? 
				goto		ASCIIHexToBin4_10	;No, go here to continue
						
				btfsc		WREG,4				;Is ASCII Hex char 0x5x or 0x7x?
				bsf			WREG,7				;Yes, set error flag
			
				andlw		0x8f				;-
				btfsc		STATUS,Z			;-is ASCII Hex char either 0x40 (@) or 0x60 (`) ?	
				bsf			WREG,7				;Yes, set error flag
				
				addlw		0x09				;Add 9 to Hex char (A-F or a-f becomes 0xa - 0xf)			
				btfsc		WREG,4				;Is result outside the 4-bit range (input character is g-o or G-O)?
				bsf			WREG,7				;Yes, set error flag
				return							;Exit

												ASCIIHexToBin4_10
				btfss		WREG,5				;Is ASCII Hex char 0x2x or 0x3x?
				bsf			WREG,7				;No, set error flag
		
				btfss		WREG,4				;Is ASCII Hex char 0x3x?
				bsf			WREG,7				;No, set error flag
		
				btfss		WREG,3				;Is ASCII Hex char 0x38-0x3f?
				goto		ASCIIHexToBin4_20	;No, go here to continue
		
				btfsc		WREG,2				;Is ASCII Hex char 0x3c-0x3f?
				bsf			WREG,7				;Yes, set error flag
		
				btfsc		WREG,1				;Is ASCII Hex char 0x3a-0x3b?
				bsf			WREG,7				;Yes, set error flag
					
												ASCIIHexToBin4_20
				andlw		0x8f				;Clear upper bits (0-9 becomes 0x0 - 0x9) 
				return							;Exit

				
				
				
				
				
Test	
				btfsc		bitHLT_CMD_RP1
				goto		Test_20
				btfsc		bitHLT_CMD_RP0
				goto		Test_10
				
				call		BUZ_On				;Turn On Buzzer 
				call		N_RST_Assert
				call		N_LCL_DeAssert
				
				bsf			bitHLT_CMD_RP0		;Set Return Path to Test_10
				return								
												Test_10		
				btfss		bit1S				;Has another second passed?
				return							;No, Exit

				call		BUZ_Off				;Turn Off Buzzer 				
				call		N_RST_DeAssert
				call		N_LCL_Assert
				
				bsf			bitHLT_CMD_RP1		;Set Return Path to Test_20
				return								
												Test_20		
				btfss		bit1S				;Has another second passed?
				return							;No, Exit
			
				bcf			bitHLT_CMD_RP1
				bcf			bitHLT_CMD_RP0
				return

				
End